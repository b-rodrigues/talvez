{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"talvez","text":""},{"location":"#talvez_1","title":"talvez","text":"<p><code>talvez</code> (maybe in both Portuguese and Spanish) is a Python implementing the maybe monad, inspired by the R package <code>maybe</code>. It provides a set of functional primitives for safe, composable handling of optional values and computations that may fail. With <code>talvez</code>, you can eliminate scattered <code>try</code>/<code>except</code> blocks, make failures explicit, and easily chain computations in a declarative, readable way. This making your code safer and more robust in the face of unexpected or missing values.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>TBC</p> <p>This package is in early alpha and requires more work. But do take a look at the tutorial!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#core-types","title":"Core types","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Holds a successfully computed / present value.</p> <p>Methods mirror those on <code>_Nothing</code>, but actually apply the provided transformations. Failures during mapping or binding gracefully degrade to <code>Nothing</code>.</p> <p>Wrap a raw value into a <code>Just</code>.</p> <p>Obtain the <code>Nothing</code> sentinel.</p> <p>Convert a standard Optional into a Maybe.</p> <p>Turn an iterator of Maybe values into a Maybe of a list.</p> <p>Short-circuits to <code>Nothing</code> if any element is <code>Nothing</code>; otherwise collects unwrapped values into a list.</p>"},{"location":"reference/#talvez.core.Just--parameters","title":"Parameters","text":"<p>value : T     The wrapped payload.</p>"},{"location":"reference/#talvez.core.Just--truthiness","title":"Truthiness","text":"<p>Evaluates to True in boolean context:</p> <pre><code>&gt;&gt;&gt; bool(just(0))\nTrue\n</code></pre>"},{"location":"reference/#talvez.core.Just--transformations","title":"Transformations","text":"<p>fmap(fn): Apply a pure function, catching exceptions -&gt; Maybe bind(fn): Chain a Maybe-returning function, validating return type</p> Source code in <code>src/talvez/core.py</code> <pre><code>@dataclass(frozen=True)\nclass Just(Generic[T]):\n    \"\"\"\n    Holds a successfully computed / present value.\n\n    Methods mirror those on `_Nothing`, but actually apply the provided\n    transformations. Failures during mapping or binding gracefully degrade\n    to `Nothing`.\n\n    Parameters\n    ----------\n    value : T\n        The wrapped payload.\n\n    Truthiness\n    ----------\n    Evaluates to True in boolean context:\n    ```pycon\n    &gt;&gt;&gt; bool(just(0))\n    True\n    ```\n\n    Transformations\n    ---------------\n    fmap(fn): Apply a pure function, catching exceptions -&gt; Maybe\n    bind(fn): Chain a Maybe-returning function, validating return type\n    \"\"\"\n\n    value: T\n\n    def __repr__(self) -&gt; str:  # pragma: no cover - trivial\n        return f\"Just({self.value!r})\"\n\n    def __bool__(self) -&gt; bool:\n        return True\n\n    # Transformations -------------------------------------------------\n\n    def fmap(self, fn: Callable[[T], U]) -&gt; \"Maybe[U]\":\n        \"\"\"\n        Apply a pure function to the contained value.\n\n        Exceptions raised by `fn` cause the result to become `Nothing`.\n\n        Parameters\n        ----------\n        fn : Callable[[T], U]\n            Pure transformation function.\n\n        Returns\n        -------\n        Maybe[U]\n            Just of transformed value, or Nothing on exception.\n        \"\"\"\n        try:\n            return just(fn(self.value))\n        except Exception:\n            return Nothing\n\n    def bind(self, fn: Callable[[T], \"Maybe[U]\"]) -&gt; \"Maybe[U]\":\n        \"\"\"\n        Chain a function returning another Maybe (monadic bind).\n\n        Enforces that `fn` returns either a `Just` or `Nothing`; any\n        other return type results in `Nothing`.\n\n        Parameters\n        ----------\n        fn : Callable[[T], Maybe[U]]\n            Function returning a Maybe.\n\n        Returns\n        -------\n        Maybe[U]\n            Result of `fn(self.value)` or Nothing on error / type mismatch.\n\n        Raises\n        ------\n        (internally caught)\n            Any exception from `fn` results in Nothing.\n        \"\"\"\n        try:\n            result = fn(self.value)\n            if not isinstance(result, (Just, _Nothing)):\n                raise TypeError(\"bind function must return a Maybe\")\n            return result\n        except Exception:\n            return Nothing\n\n    # Extraction ------------------------------------------------------\n\n    def get_or(self, default: U) -&gt; Union[T, U]:\n        \"\"\"\n        Return the wrapped value (ignoring the default).\n\n        Provided for API symmetry with `_Nothing.get_or`.\n\n        Parameters\n        ----------\n        default : U\n            (Unused) placeholder for symmetry.\n\n        Returns\n        -------\n        T\n            The contained value.\n        \"\"\"\n        return self.value\n\n    def to_optional(self) -&gt; Optional[T]:\n        \"\"\"\n        Convert to a standard Optional (always the underlying value here).\n\n        Returns\n        -------\n        Optional[T]\n            The contained value (never None unless it was explicitly None).\n        \"\"\"\n        return self.value\n\n    # Introspection ---------------------------------------------------\n\n    @property\n    def is_nothing(self) -&gt; bool:\n        \"\"\"Return False (this is a Just).\"\"\"\n        return False\n\n    @property\n    def is_just(self) -&gt; bool:\n        \"\"\"Return True (this is a Just).\"\"\"\n        return True\n</code></pre>"},{"location":"reference/#talvez.core.Just.is_just","title":"<code>is_just</code>  <code>property</code>","text":"<p>Return True (this is a Just).</p>"},{"location":"reference/#talvez.core.Just.is_nothing","title":"<code>is_nothing</code>  <code>property</code>","text":"<p>Return False (this is a Just).</p>"},{"location":"reference/#talvez.core.Just.bind","title":"<code>bind(fn)</code>","text":"<p>Chain a function returning another Maybe (monadic bind).</p> <p>Enforces that <code>fn</code> returns either a <code>Just</code> or <code>Nothing</code>; any other return type results in <code>Nothing</code>.</p>"},{"location":"reference/#talvez.core.Just.bind--parameters","title":"Parameters","text":"<p>fn : Callable[[T], Maybe[U]]     Function returning a Maybe.</p>"},{"location":"reference/#talvez.core.Just.bind--returns","title":"Returns","text":"<p>Maybe[U]     Result of <code>fn(self.value)</code> or Nothing on error / type mismatch.</p>"},{"location":"reference/#talvez.core.Just.bind--raises","title":"Raises","text":"<p>(internally caught)     Any exception from <code>fn</code> results in Nothing.</p> Source code in <code>src/talvez/core.py</code> <pre><code>def bind(self, fn: Callable[[T], \"Maybe[U]\"]) -&gt; \"Maybe[U]\":\n    \"\"\"\n    Chain a function returning another Maybe (monadic bind).\n\n    Enforces that `fn` returns either a `Just` or `Nothing`; any\n    other return type results in `Nothing`.\n\n    Parameters\n    ----------\n    fn : Callable[[T], Maybe[U]]\n        Function returning a Maybe.\n\n    Returns\n    -------\n    Maybe[U]\n        Result of `fn(self.value)` or Nothing on error / type mismatch.\n\n    Raises\n    ------\n    (internally caught)\n        Any exception from `fn` results in Nothing.\n    \"\"\"\n    try:\n        result = fn(self.value)\n        if not isinstance(result, (Just, _Nothing)):\n            raise TypeError(\"bind function must return a Maybe\")\n        return result\n    except Exception:\n        return Nothing\n</code></pre>"},{"location":"reference/#talvez.core.Just.fmap","title":"<code>fmap(fn)</code>","text":"<p>Apply a pure function to the contained value.</p> <p>Exceptions raised by <code>fn</code> cause the result to become <code>Nothing</code>.</p>"},{"location":"reference/#talvez.core.Just.fmap--parameters","title":"Parameters","text":"<p>fn : Callable[[T], U]     Pure transformation function.</p>"},{"location":"reference/#talvez.core.Just.fmap--returns","title":"Returns","text":"<p>Maybe[U]     Just of transformed value, or Nothing on exception.</p> Source code in <code>src/talvez/core.py</code> <pre><code>def fmap(self, fn: Callable[[T], U]) -&gt; \"Maybe[U]\":\n    \"\"\"\n    Apply a pure function to the contained value.\n\n    Exceptions raised by `fn` cause the result to become `Nothing`.\n\n    Parameters\n    ----------\n    fn : Callable[[T], U]\n        Pure transformation function.\n\n    Returns\n    -------\n    Maybe[U]\n        Just of transformed value, or Nothing on exception.\n    \"\"\"\n    try:\n        return just(fn(self.value))\n    except Exception:\n        return Nothing\n</code></pre>"},{"location":"reference/#talvez.core.Just.get_or","title":"<code>get_or(default)</code>","text":"<p>Return the wrapped value (ignoring the default).</p> <p>Provided for API symmetry with <code>_Nothing.get_or</code>.</p>"},{"location":"reference/#talvez.core.Just.get_or--parameters","title":"Parameters","text":"<p>default : U     (Unused) placeholder for symmetry.</p>"},{"location":"reference/#talvez.core.Just.get_or--returns","title":"Returns","text":"<p>T     The contained value.</p> Source code in <code>src/talvez/core.py</code> <pre><code>def get_or(self, default: U) -&gt; Union[T, U]:\n    \"\"\"\n    Return the wrapped value (ignoring the default).\n\n    Provided for API symmetry with `_Nothing.get_or`.\n\n    Parameters\n    ----------\n    default : U\n        (Unused) placeholder for symmetry.\n\n    Returns\n    -------\n    T\n        The contained value.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/#talvez.core.Just.to_optional","title":"<code>to_optional()</code>","text":"<p>Convert to a standard Optional (always the underlying value here).</p>"},{"location":"reference/#talvez.core.Just.to_optional--returns","title":"Returns","text":"<p>Optional[T]     The contained value (never None unless it was explicitly None).</p> Source code in <code>src/talvez/core.py</code> <pre><code>def to_optional(self) -&gt; Optional[T]:\n    \"\"\"\n    Convert to a standard Optional (always the underlying value here).\n\n    Returns\n    -------\n    Optional[T]\n        The contained value (never None unless it was explicitly None).\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/#talvez.core.just--parameters","title":"Parameters","text":"<p>a : T     Value to wrap.</p>"},{"location":"reference/#talvez.core.just--returns","title":"Returns","text":"<p>Just[T]     A Maybe representing presence.</p> Source code in <code>src/talvez/core.py</code> <pre><code>def just(a: T) -&gt; Just[T]:\n    \"\"\"\n    Wrap a raw value into a `Just`.\n\n    Parameters\n    ----------\n    a : T\n        Value to wrap.\n\n    Returns\n    -------\n    Just[T]\n        A Maybe representing presence.\n    \"\"\"\n    return Just(a)\n</code></pre>"},{"location":"reference/#talvez.core.nothing--returns","title":"Returns","text":"<p>_Nothing     The shared singleton representing absence.</p> Source code in <code>src/talvez/core.py</code> <pre><code>def nothing() -&gt; _Nothing:\n    \"\"\"\n    Obtain the `Nothing` sentinel.\n\n    Returns\n    -------\n    _Nothing\n        The shared singleton representing absence.\n    \"\"\"\n    return Nothing\n</code></pre>"},{"location":"reference/#talvez.core.from_optional--parameters","title":"Parameters","text":"<p>opt : Optional[T]     An optional value (None indicates absence).</p>"},{"location":"reference/#talvez.core.from_optional--returns","title":"Returns","text":"<p>Maybe[T]     <code>Just(opt)</code> if not None, else <code>Nothing</code>.</p> Source code in <code>src/talvez/core.py</code> <pre><code>def from_optional(opt: Optional[T]) -&gt; Maybe[T]:\n    \"\"\"\n    Convert a standard Optional into a Maybe.\n\n    Parameters\n    ----------\n    opt : Optional[T]\n        An optional value (None indicates absence).\n\n    Returns\n    -------\n    Maybe[T]\n        `Just(opt)` if not None, else `Nothing`.\n    \"\"\"\n    return nothing() if opt is None else just(opt)\n</code></pre>"},{"location":"reference/#talvez.core.sequence--parameters","title":"Parameters","text":"<p>maybes : Iterator[Maybe[T]]     Iterator yielding Maybe values.</p>"},{"location":"reference/#talvez.core.sequence--returns","title":"Returns","text":"<p>Maybe[list[T]]     Just of collected values if all succeed, else Nothing.</p>"},{"location":"reference/#talvez.core.sequence--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; sequence(iter([just(1), just(2)])).get_or([])\n[1, 2]\n&gt;&gt;&gt; sequence(iter([just(1), nothing(), just(3)])).is_nothing\nTrue\n</code></pre> Source code in <code>src/talvez/core.py</code> <pre><code>def sequence(maybes: Iterator[Maybe[T]]) -&gt; Maybe[list[T]]:\n    \"\"\"\n    Turn an iterator of Maybe values into a Maybe of a list.\n\n    Short-circuits to `Nothing` if any element is `Nothing`; otherwise\n    collects unwrapped values into a list.\n\n    Parameters\n    ----------\n    maybes : Iterator[Maybe[T]]\n        Iterator yielding Maybe values.\n\n    Returns\n    -------\n    Maybe[list[T]]\n        Just of collected values if all succeed, else Nothing.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; sequence(iter([just(1), just(2)])).get_or([])\n    [1, 2]\n    &gt;&gt;&gt; sequence(iter([just(1), nothing(), just(3)])).is_nothing\n    True\n    ```\n    \"\"\"\n    out: list[T] = []\n    for m in maybes:\n        if isinstance(m, _Nothing):\n            return Nothing\n        out.append(m.value)  # type: ignore[attr-defined]\n    return just(out)\n</code></pre>"},{"location":"reference/#decorators","title":"Decorators","text":"<p>Decorator factory: wrap a function so it returns a Maybe (Just / Nothing).</p> The wrapped function is executed inside a protective layer that <ol> <li>Captures exceptions -&gt; returns <code>Nothing</code></li> <li>Optionally treats warnings as failures (<code>allow_warning=False</code>)</li> <li>Applies an <code>ensure</code> predicate to the result; non-True -&gt; <code>Nothing</code></li> <li>Returns <code>Just(result)</code> on success</li> </ol> <p>IMPORTANT: The <code>ensure</code> predicate must return the literal boolean <code>True</code> for acceptance. Returning any other truthy object (e.g., 1, non-empty list) will be considered failure because <code>talvez.predicates.not_true</code> checks for identity with <code>True</code>. This enforces discipline and avoids accidental truthiness bugs.</p> <p>Decorator factory: wrap a function so it returns a raw value with fallback.</p> <p>Unlike <code>maybe</code>, this returns the successful result directly, or a user-specified <code>default</code> on failure. Failure conditions mirror <code>maybe</code>:   - Exception raised   - Warning emitted (if <code>allow_warning=False</code>)   - Ensure predicate not returning literal True   - Ensure predicate raising an exception</p> <p>ensure predicate behavior</p> <p>The <code>ensure</code> callable MUST return the literal boolean <code>True</code> (not just a truthy value) for a result to be accepted. Anything else (False, 1, [], object()) is treated as failure. This is enforced via the <code>not_true</code> predicate for defensive programming.</p> <p>Choosing between maybe() and perhaps()</p> <ul> <li>Use <code>@maybe()</code> when you want explicit <code>Just</code> / <code>Nothing</code> handling.</li> <li>Use <code>@perhaps(default=...)</code> when a sentinel fallback is more ergonomic.</li> </ul>"},{"location":"reference/#talvez.wrappers.maybe--parameters","title":"Parameters","text":"<p>ensure : Optional[Callable[[Any], bool]], default=None     Predicate applied to the successful raw result. If omitted, all results     are accepted. If the predicate raises an exception or returns anything     other than the literal <code>True</code>, the outcome becomes <code>Nothing</code>. allow_warning : bool, default=False     If False, any warning raised during execution causes the decorator to     return <code>Nothing</code>. If True, warnings are ignored.</p>"},{"location":"reference/#talvez.wrappers.maybe--returns","title":"Returns","text":"<p>Callable[[Callable[..., T]], Callable[..., Maybe[T]]]     A decorator that transforms a function returning T into one returning     <code>Maybe[T]</code>.</p>"},{"location":"reference/#talvez.wrappers.maybe--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from talvez import just, nothing\n&gt;&gt;&gt; @maybe()\n... def parse_int(s: str) -&gt; int:\n...     return int(s)\n...\n&gt;&gt;&gt; parse_int(\"10\").get_or(None)\n10\n&gt;&gt;&gt; parse_int(\"x\").is_nothing\nTrue\n</code></pre> <p>With an ensure predicate:</p> <pre><code>&gt;&gt;&gt; @maybe(ensure=lambda v: v &gt; 0)\n... def delta(x): return x - 1\n...\n&gt;&gt;&gt; delta(5).is_just\nTrue\n&gt;&gt;&gt; delta(0).is_nothing   # ensure failed (returns -1)\nTrue\n</code></pre> <p>Handling warnings:</p> <pre><code>&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; @maybe(allow_warning=False)\n... def risky():\n...     warnings.warn(\"deprecated\")\n...     return 42\n...\n&gt;&gt;&gt; risky().is_nothing\nTrue\n&gt;&gt;&gt; @maybe(allow_warning=True)\n... def tolerant():\n...     warnings.warn(\"deprecated\")\n...     return 42\n...\n&gt;&gt;&gt; tolerant().get_or(None)\n42\n</code></pre>"},{"location":"reference/#talvez.wrappers.maybe--edge-cases","title":"Edge Cases","text":"<ul> <li>Exception in function: returns <code>Nothing</code></li> <li>Exception in ensure predicate: returns <code>Nothing</code></li> <li>Warning + allow_warning=False: returns <code>Nothing</code></li> <li>Function returns None and ensure not provided: wraps as Just(None)   (use ensure to reject None if undesired).</li> </ul> Source code in <code>src/talvez/wrappers.py</code> <pre><code>def maybe(\n    ensure: Optional[Callable[[Any], bool]] = None,\n    allow_warning: bool = False\n):\n    \"\"\"\n    Decorator factory: wrap a function so it returns a Maybe (Just / Nothing).\n\n    The wrapped function is executed inside a protective layer that:\n      1. Captures exceptions -&gt; returns `Nothing`\n      2. Optionally treats warnings as failures (`allow_warning=False`)\n      3. Applies an `ensure` predicate to the result; non-True -&gt; `Nothing`\n      4. Returns `Just(result)` on success\n\n    IMPORTANT: The `ensure` predicate must return the literal boolean `True`\n    for acceptance. Returning any other truthy object (e.g., 1, non-empty list)\n    will be considered failure because `talvez.predicates.not_true` checks for\n    identity with `True`. This enforces discipline and avoids accidental\n    truthiness bugs.\n\n    Parameters\n    ----------\n    ensure : Optional[Callable[[Any], bool]], default=None\n        Predicate applied to the successful raw result. If omitted, all results\n        are accepted. If the predicate raises an exception or returns anything\n        other than the literal `True`, the outcome becomes `Nothing`.\n    allow_warning : bool, default=False\n        If False, any warning raised during execution causes the decorator to\n        return `Nothing`. If True, warnings are ignored.\n\n    Returns\n    -------\n    Callable[[Callable[..., T]], Callable[..., Maybe[T]]]\n        A decorator that transforms a function returning T into one returning\n        `Maybe[T]`.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; from talvez import just, nothing\n    &gt;&gt;&gt; @maybe()\n    ... def parse_int(s: str) -&gt; int:\n    ...     return int(s)\n    ...\n    &gt;&gt;&gt; parse_int(\"10\").get_or(None)\n    10\n    &gt;&gt;&gt; parse_int(\"x\").is_nothing\n    True\n    ```\n\n    With an ensure predicate:\n\n    ```pycon\n    &gt;&gt;&gt; @maybe(ensure=lambda v: v &gt; 0)\n    ... def delta(x): return x - 1\n    ...\n    &gt;&gt;&gt; delta(5).is_just\n    True\n    &gt;&gt;&gt; delta(0).is_nothing   # ensure failed (returns -1)\n    True\n    ```\n\n    Handling warnings:\n\n    ```pycon\n    &gt;&gt;&gt; import warnings\n    &gt;&gt;&gt; @maybe(allow_warning=False)\n    ... def risky():\n    ...     warnings.warn(\"deprecated\")\n    ...     return 42\n    ...\n    &gt;&gt;&gt; risky().is_nothing\n    True\n    &gt;&gt;&gt; @maybe(allow_warning=True)\n    ... def tolerant():\n    ...     warnings.warn(\"deprecated\")\n    ...     return 42\n    ...\n    &gt;&gt;&gt; tolerant().get_or(None)\n    42\n    ```\n\n    Edge Cases\n    ----------\n    - Exception in function: returns `Nothing`\n    - Exception in ensure predicate: returns `Nothing`\n    - Warning + allow_warning=False: returns `Nothing`\n    - Function returns None and ensure not provided: wraps as Just(None)\n      (use ensure to reject None if undesired).\n    \"\"\"\n    ensure_fn = ensure if ensure is not None else (lambda a: True)\n\n    def deco(f: Callable[..., T]):\n        @wraps(f)\n        def wrapped(*args, **kwargs) -&gt; Maybe[T]:\n            try:\n                result = _with_warning_capture(lambda: f(*args, **kwargs), allow_warning)\n            except Exception:\n                return nothing()\n            try:\n                if not_true(ensure_fn(result)):\n                    return nothing()\n            except Exception:\n                return nothing()\n            return just(result)\n        return wrapped\n    return deco\n</code></pre>"},{"location":"reference/#talvez.wrappers.perhaps--parameters","title":"Parameters","text":"<p>default : Any     The value returned when the wrapped function \"fails\". Should be a     sensible sentinel consistent with your domain. ensure : Optional[Callable[[Any], bool]], default=None     Predicate validating the raw result. Must return the literal True to     accept; any other outcome triggers the fallback. allow_warning : bool, default=False     If False, any warning turns the result into <code>default</code>. If True, warnings     are ignored.</p>"},{"location":"reference/#talvez.wrappers.perhaps--returns","title":"Returns","text":"<p>Callable[[Callable[..., T]], Callable[..., Any]]     A decorator that converts a function returning T into one returning     T-or-default.</p>"},{"location":"reference/#talvez.wrappers.perhaps--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; @perhaps(default=0)\n... def safe_div(a, b): return a / b\n...\n&gt;&gt;&gt; safe_div(10, 2)\n5.0\n&gt;&gt;&gt; safe_div(10, 0)\n0\n</code></pre> <p>With ensure:</p> <pre><code>&gt;&gt;&gt; @perhaps(default=None, ensure=lambda v: v &gt; 10)\n... def compute(x): return x * 3\n...\n&gt;&gt;&gt; compute(5)\n15\n&gt;&gt;&gt; compute(3)  # 3*3 = 9 -&gt; ensure fails\nNone\n</code></pre> <p>Warning handling:</p> <pre><code>&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; @perhaps(default=-1, allow_warning=False)\n... def noisy():\n...     warnings.warn(\"careful\")\n...     return 99\n...\n&gt;&gt;&gt; noisy()\n-1\n</code></pre>"},{"location":"reference/#talvez.wrappers.perhaps--design-rationale","title":"Design Rationale","text":"<p>Use <code>perhaps</code> when you want ergonomic fallback semantics without having to manipulate a Maybe object explicitly, for contexts where sentinel defaults are acceptable and clearly documented.</p>"},{"location":"reference/#talvez.wrappers.perhaps--edge-cases","title":"Edge Cases","text":"<ul> <li>If the function legitimately returns a value equal to <code>default</code>, you   cannot distinguish fallback vs success\u2014choose a unique sentinel if needed.</li> <li>As with <code>maybe</code>, ensure must return literal True (not just truthy).</li> </ul> Source code in <code>src/talvez/wrappers.py</code> <pre><code>def perhaps(\n    default: Any,\n    ensure: Optional[Callable[[Any], bool]] = None,\n    allow_warning: bool = False\n):\n    \"\"\"\n    Decorator factory: wrap a function so it returns a raw value with fallback.\n\n    Unlike `maybe`, this returns the successful result directly, or a\n    user-specified `default` on failure. Failure conditions mirror `maybe`:\n      - Exception raised\n      - Warning emitted (if `allow_warning=False`)\n      - Ensure predicate not returning literal True\n      - Ensure predicate raising an exception\n\n    Parameters\n    ----------\n    default : Any\n        The value returned when the wrapped function \"fails\". Should be a\n        sensible sentinel consistent with your domain.\n    ensure : Optional[Callable[[Any], bool]], default=None\n        Predicate validating the raw result. Must return the literal True to\n        accept; any other outcome triggers the fallback.\n    allow_warning : bool, default=False\n        If False, any warning turns the result into `default`. If True, warnings\n        are ignored.\n\n    Returns\n    -------\n    Callable[[Callable[..., T]], Callable[..., Any]]\n        A decorator that converts a function returning T into one returning\n        T-or-default.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; @perhaps(default=0)\n    ... def safe_div(a, b): return a / b\n    ...\n    &gt;&gt;&gt; safe_div(10, 2)\n    5.0\n    &gt;&gt;&gt; safe_div(10, 0)\n    0\n    ```\n\n    With ensure:\n\n    ```pycon\n    &gt;&gt;&gt; @perhaps(default=None, ensure=lambda v: v &gt; 10)\n    ... def compute(x): return x * 3\n    ...\n    &gt;&gt;&gt; compute(5)\n    15\n    &gt;&gt;&gt; compute(3)  # 3*3 = 9 -&gt; ensure fails\n    None\n    ```\n\n    Warning handling:\n\n    ```pycon\n    &gt;&gt;&gt; import warnings\n    &gt;&gt;&gt; @perhaps(default=-1, allow_warning=False)\n    ... def noisy():\n    ...     warnings.warn(\"careful\")\n    ...     return 99\n    ...\n    &gt;&gt;&gt; noisy()\n    -1\n    ```\n\n    Design Rationale\n    ----------------\n    Use `perhaps` when you want ergonomic fallback semantics without having to\n    manipulate a Maybe object explicitly, for contexts where sentinel defaults\n    are acceptable and clearly documented.\n\n    Edge Cases\n    ----------\n    - If the function legitimately returns a value equal to `default`, you\n      cannot distinguish fallback vs success\u2014choose a unique sentinel if needed.\n    - As with `maybe`, ensure must return literal True (not just truthy).\n    \"\"\"\n    ensure_fn = ensure if ensure is not None else (lambda a: True)\n\n    def deco(f: Callable[..., T]):\n        @wraps(f)\n        def wrapped(*args, **kwargs) -&gt; Any:\n            try:\n                result = _with_warning_capture(lambda: f(*args, **kwargs), allow_warning)\n            except Exception:\n                return default\n            try:\n                if not_true(ensure_fn(result)):\n                    return default\n            except Exception:\n                return default\n            return result\n        return wrapped\n    return deco\n</code></pre>"},{"location":"reference/#composition-and-chaining","title":"Composition and chaining","text":"<p>Sequentially apply a series of Maybe-producing functions, short-circuiting on the first failure.</p> <p>This function implements a left-to-right monadic bind chain. It starts with an initial Maybe <code>m</code> and applies each function in <code>fns</code> to the unwrapped value of the current <code>Just</code> (via <code>bind</code>). If at any point the current value is <code>Nothing</code>, evaluation stops early and <code>Nothing</code> is returned.</p> <p>Compose multiple Maybe-producing functions into a reusable pipeline.</p> <p>Returns a new function that expects an initial <code>Maybe</code> and applies the provided functions in order using <code>chain</code>. This is useful when you want to define a processing pipeline once and reuse it across different starting values.</p>"},{"location":"reference/#talvez.ops.chain--parameters","title":"Parameters","text":"<p>m : Maybe[Any]     The initial Maybe value (typically <code>just(x)</code> or <code>nothing()</code>). *fns : Callable[[Any], Maybe[Any]]     A variadic sequence of functions. Each function must accept the unwrapped     value from the previous <code>Just</code> and return a new <code>Maybe</code>.</p>"},{"location":"reference/#talvez.ops.chain--returns","title":"Returns","text":"<p>Maybe[Any]     The resulting Maybe after applying all functions, or the first <code>Nothing</code>     encountered.</p>"},{"location":"reference/#talvez.ops.chain--notes","title":"Notes","text":"<ul> <li>This is analogous to a fold/ reduce over monadic bind operations.</li> <li>Functions are only invoked if the current accumulator is a <code>Just</code>.</li> <li>Any function returning <code>Nothing</code> halts further processing.</li> </ul>"},{"location":"reference/#talvez.ops.chain--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from talvez import just, nothing\n&gt;&gt;&gt; def parse_int(s: str):\n...     try:\n...         return just(int(s))\n...     except ValueError:\n...         return nothing()\n...\n&gt;&gt;&gt; def reciprocal(x: int):\n...     return nothing() if x == 0 else just(1 / x)\n...\n&gt;&gt;&gt; chain(just(\"10\"), parse_int, reciprocal).get_or(None)\n0.1\n&gt;&gt;&gt; chain(just(\"foo\"), parse_int, reciprocal).is_nothing\nTrue\n</code></pre>"},{"location":"reference/#talvez.ops.chain--edge-cases","title":"Edge Cases","text":"<ul> <li>Passing no functions: returns the original <code>m</code>.</li> <li>If <code>m</code> is already <code>Nothing</code>, no functions are executed.</li> </ul> Source code in <code>src/talvez/ops.py</code> <pre><code>def chain(m: Maybe[Any], *fns: Callable[[Any], Maybe[Any]]) -&gt; Maybe[Any]:\n    \"\"\"\n    Sequentially apply a series of Maybe-producing functions, short-circuiting on the first failure.\n\n    This function implements a left-to-right monadic bind chain. It starts with an\n    initial Maybe `m` and applies each function in `fns` to the unwrapped value\n    of the current `Just` (via `bind`). If at any point the current value is\n    `Nothing`, evaluation stops early and `Nothing` is returned.\n\n    Parameters\n    ----------\n    m : Maybe[Any]\n        The initial Maybe value (typically `just(x)` or `nothing()`).\n    *fns : Callable[[Any], Maybe[Any]]\n        A variadic sequence of functions. Each function must accept the unwrapped\n        value from the previous `Just` and return a new `Maybe`.\n\n    Returns\n    -------\n    Maybe[Any]\n        The resulting Maybe after applying all functions, or the first `Nothing`\n        encountered.\n\n    Notes\n    -----\n    - This is analogous to a fold/ reduce over monadic bind operations.\n    - Functions are only invoked if the current accumulator is a `Just`.\n    - Any function returning `Nothing` halts further processing.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; from talvez import just, nothing\n    &gt;&gt;&gt; def parse_int(s: str):\n    ...     try:\n    ...         return just(int(s))\n    ...     except ValueError:\n    ...         return nothing()\n    ...\n    &gt;&gt;&gt; def reciprocal(x: int):\n    ...     return nothing() if x == 0 else just(1 / x)\n    ...\n    &gt;&gt;&gt; chain(just(\"10\"), parse_int, reciprocal).get_or(None)\n    0.1\n    &gt;&gt;&gt; chain(just(\"foo\"), parse_int, reciprocal).is_nothing\n    True\n    ```\n\n    Edge Cases\n    ----------\n    - Passing no functions: returns the original `m`.\n    - If `m` is already `Nothing`, no functions are executed.\n    \"\"\"\n    current: Maybe[Any] = m\n    for fn in fns:\n        if current.is_nothing:  # type: ignore[attr-defined]\n            break\n        current = current.bind(fn)  # type: ignore[arg-type]\n    return current\n</code></pre>"},{"location":"reference/#talvez.ops.compose_maybe--parameters","title":"Parameters","text":"<p>*fns : Callable[[Any], Maybe[Any]]     A sequence of functions, each taking a plain (unwrapped) value and     returning a <code>Maybe</code>.</p>"},{"location":"reference/#talvez.ops.compose_maybe--returns","title":"Returns","text":"<p>Callable[[Maybe[Any]], Maybe[Any]]     A function that, given an initial <code>Maybe</code>, applies the pipeline.</p>"},{"location":"reference/#talvez.ops.compose_maybe--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from talvez import just, nothing\n&gt;&gt;&gt; def non_empty(s: str):\n...     return just(s) if s else nothing()\n...\n&gt;&gt;&gt; def to_int(s: str):\n...     try:\n...         return just(int(s))\n...     except ValueError:\n...         return nothing()\n...\n&gt;&gt;&gt; def positive(x: int):\n...         return just(x) if x &gt; 0 else nothing()\n...\n&gt;&gt;&gt; pipeline = compose_maybe(non_empty, to_int, positive)\n&gt;&gt;&gt; pipeline(just(\"42\")).get_or(None)\n42\n&gt;&gt;&gt; pipeline(just(\"\")).is_nothing\nTrue\n&gt;&gt;&gt; pipeline(just(\"-5\")).is_nothing\nTrue\n</code></pre>"},{"location":"reference/#talvez.ops.compose_maybe--comparison","title":"Comparison","text":"<p>This:     pipeline = compose_maybe(f1, f2, f3)     result = pipeline(just(x)) Is equivalent to:     result = chain(just(x), f1, f2, f3)</p>"},{"location":"reference/#talvez.ops.compose_maybe--edge-cases","title":"Edge Cases","text":"<ul> <li>If no functions are provided, the returned runner is the identity on <code>Maybe</code>.</li> <li>Fail-fast semantics are inherited from <code>chain</code>.</li> </ul> Source code in <code>src/talvez/ops.py</code> <pre><code>def compose_maybe(*fns: Callable[[Any], Maybe[Any]]):\n    \"\"\"\n    Compose multiple Maybe-producing functions into a reusable pipeline.\n\n    Returns a new function that expects an initial `Maybe` and applies the\n    provided functions in order using `chain`. This is useful when you want to\n    define a processing pipeline once and reuse it across different starting\n    values.\n\n    Parameters\n    ----------\n    *fns : Callable[[Any], Maybe[Any]]\n        A sequence of functions, each taking a plain (unwrapped) value and\n        returning a `Maybe`.\n\n    Returns\n    -------\n    Callable[[Maybe[Any]], Maybe[Any]]\n        A function that, given an initial `Maybe`, applies the pipeline.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; from talvez import just, nothing\n    &gt;&gt;&gt; def non_empty(s: str):\n    ...     return just(s) if s else nothing()\n    ...\n    &gt;&gt;&gt; def to_int(s: str):\n    ...     try:\n    ...         return just(int(s))\n    ...     except ValueError:\n    ...         return nothing()\n    ...\n    &gt;&gt;&gt; def positive(x: int):\n    ...         return just(x) if x &gt; 0 else nothing()\n    ...\n    &gt;&gt;&gt; pipeline = compose_maybe(non_empty, to_int, positive)\n    &gt;&gt;&gt; pipeline(just(\"42\")).get_or(None)\n    42\n    &gt;&gt;&gt; pipeline(just(\"\")).is_nothing\n    True\n    &gt;&gt;&gt; pipeline(just(\"-5\")).is_nothing\n    True\n    ```\n\n    Comparison\n    ----------\n    This:\n        pipeline = compose_maybe(f1, f2, f3)\n        result = pipeline(just(x))\n    Is equivalent to:\n        result = chain(just(x), f1, f2, f3)\n\n    Edge Cases\n    ----------\n    - If no functions are provided, the returned runner is the identity on `Maybe`.\n    - Fail-fast semantics are inherited from `chain`.\n    \"\"\"\n    def runner(m: Maybe[Any]) -&gt; Maybe[Any]:\n        return chain(m, *fns)\n    return runner\n</code></pre>"},{"location":"reference/#predicates","title":"Predicates","text":"<p>Return True if the argument is NOT the literal boolean True.</p> <p>This helper is intentionally strict: it only treats the single object <code>True</code> as true-ish for the negation test. Any other truthy value (e.g., 1, \"yes\", non\u2011empty containers) returns True because it is not the singleton <code>True</code>.</p> <p>Return True if the value is not None.</p> <p>Return True if the value is NOT a floating-point NaN (Not-a-Number).</p> <p>Return True if the value is not positive or negative infinity.</p> <p>Composite predicate: value is neither None, NaN, nor infinite.</p> This is a convenience aggregator combining <ul> <li>not_null</li> <li>not_nan</li> <li>not_infinite</li> </ul> <p>Return True if the object has a length &gt; 0, or if it has no length concept.</p> Semantics <ul> <li>If the object implements len, returns len(a) &gt; 0.</li> <li>If it does not (AttributeError / TypeError), treats it as \"not empty\"   and returns True (optimistic / permissive behavior).</li> </ul>"},{"location":"reference/#talvez.predicates.not_true--parameters","title":"Parameters","text":"<p>x : Any     Value to test for identity with the boolean <code>True</code>.</p>"},{"location":"reference/#talvez.predicates.not_true--returns","title":"Returns","text":"<p>bool     False only when <code>x is True</code>; True otherwise.</p>"},{"location":"reference/#talvez.predicates.not_true--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; not_true(True)\nFalse\n&gt;&gt;&gt; not_true(False)\nTrue\n&gt;&gt;&gt; not_true(1)\nTrue\n&gt;&gt;&gt; not_true(\"anything\")\nTrue\n</code></pre>"},{"location":"reference/#talvez.predicates.not_true--notes","title":"Notes","text":"<p>This function is used internally to implement other predicates without conflating general truthiness with strict identity to <code>True</code>.</p> Source code in <code>src/talvez/predicates.py</code> <pre><code>def not_true(x: Any) -&gt; bool:\n    \"\"\"\n    Return True if the argument is NOT the literal boolean True.\n\n    This helper is intentionally strict: it only treats the single object `True`\n    as true-ish for the negation test. Any other truthy value (e.g., 1, \"yes\",\n    non\u2011empty containers) returns True because it is not the singleton `True`.\n\n    Parameters\n    ----------\n    x : Any\n        Value to test for identity with the boolean `True`.\n\n    Returns\n    -------\n    bool\n        False only when `x is True`; True otherwise.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; not_true(True)\n    False\n    &gt;&gt;&gt; not_true(False)\n    True\n    &gt;&gt;&gt; not_true(1)\n    True\n    &gt;&gt;&gt; not_true(\"anything\")\n    True\n    ```\n\n    Notes\n    -----\n    This function is used internally to implement other predicates without\n    conflating general truthiness with strict identity to `True`.\n    \"\"\"\n    return not (x is True)\n</code></pre>"},{"location":"reference/#talvez.predicates.not_null--parameters","title":"Parameters","text":"<p>a : Any     Value to check.</p>"},{"location":"reference/#talvez.predicates.not_null--returns","title":"Returns","text":"<p>bool     True if <code>a is not None</code>, False otherwise.</p>"},{"location":"reference/#talvez.predicates.not_null--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; not_null(None)\nFalse\n&gt;&gt;&gt; not_null(0)\nTrue\n&gt;&gt;&gt; not_null(\"\")\nTrue\n</code></pre> Source code in <code>src/talvez/predicates.py</code> <pre><code>def not_null(a: Any) -&gt; bool:\n    \"\"\"\n    Return True if the value is not None.\n\n    Parameters\n    ----------\n    a : Any\n        Value to check.\n\n    Returns\n    -------\n    bool\n        True if `a is not None`, False otherwise.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; not_null(None)\n    False\n    &gt;&gt;&gt; not_null(0)\n    True\n    &gt;&gt;&gt; not_null(\"\")\n    True\n    ```\n    \"\"\"\n    # Intentionally phrased via not_true for internal stylistic consistency.\n    return not_true(a is None)\n</code></pre>"},{"location":"reference/#talvez.predicates.not_nan--parameters","title":"Parameters","text":"<p>a : Any     Value to check. Only floats are considered; other types return True.</p>"},{"location":"reference/#talvez.predicates.not_nan--returns","title":"Returns","text":"<p>bool     False only when <code>a</code> is a float and <code>math.isnan(a)</code> is True.</p>"},{"location":"reference/#talvez.predicates.not_nan--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; not_nan(float(\"nan\"))\nFalse\n&gt;&gt;&gt; not_nan(3.14)\nTrue\n&gt;&gt;&gt; not_nan(\"nan\")\nTrue\n</code></pre> Source code in <code>src/talvez/predicates.py</code> <pre><code>def not_nan(a: Any) -&gt; bool:\n    \"\"\"\n    Return True if the value is NOT a floating-point NaN (Not-a-Number).\n\n    Parameters\n    ----------\n    a : Any\n        Value to check. Only floats are considered; other types return True.\n\n    Returns\n    -------\n    bool\n        False only when `a` is a float and `math.isnan(a)` is True.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; not_nan(float(\"nan\"))\n    False\n    &gt;&gt;&gt; not_nan(3.14)\n    True\n    &gt;&gt;&gt; not_nan(\"nan\")\n    True\n    ```\n    \"\"\"\n    return not (isinstance(a, float) and math.isnan(a))\n</code></pre>"},{"location":"reference/#talvez.predicates.not_infinite--parameters","title":"Parameters","text":"<p>a : Any     Value to check. Only ints/floats are considered for +/- infinity.</p>"},{"location":"reference/#talvez.predicates.not_infinite--returns","title":"Returns","text":"<p>bool     False when <code>a</code> is +inf or -inf (as a numeric); True otherwise.</p>"},{"location":"reference/#talvez.predicates.not_infinite--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; not_infinite(float(\"inf\"))\nFalse\n&gt;&gt;&gt; not_infinite(float(\"-inf\"))\nFalse\n&gt;&gt;&gt; not_infinite(42)\nTrue\n&gt;&gt;&gt; not_infinite(\"inf\")\nTrue\n</code></pre> Source code in <code>src/talvez/predicates.py</code> <pre><code>def not_infinite(a: Any) -&gt; bool:\n    \"\"\"\n    Return True if the value is not positive or negative infinity.\n\n    Parameters\n    ----------\n    a : Any\n        Value to check. Only ints/floats are considered for +/- infinity.\n\n    Returns\n    -------\n    bool\n        False when `a` is +inf or -inf (as a numeric); True otherwise.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; not_infinite(float(\"inf\"))\n    False\n    &gt;&gt;&gt; not_infinite(float(\"-inf\"))\n    False\n    &gt;&gt;&gt; not_infinite(42)\n    True\n    &gt;&gt;&gt; not_infinite(\"inf\")\n    True\n    ```\n    \"\"\"\n    return not (isinstance(a, (float, int)) and (a == float(\"inf\") or a == float(\"-inf\")))\n</code></pre>"},{"location":"reference/#talvez.predicates.not_undefined--parameters","title":"Parameters","text":"<p>a : Any     Value to test.</p>"},{"location":"reference/#talvez.predicates.not_undefined--returns","title":"Returns","text":"<p>bool     True only if all component predicates pass.</p>"},{"location":"reference/#talvez.predicates.not_undefined--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; not_undefined(None)\nFalse\n&gt;&gt;&gt; not_undefined(float(\"nan\"))\nFalse\n&gt;&gt;&gt; not_undefined(float(\"inf\"))\nFalse\n&gt;&gt;&gt; not_undefined(0)\nTrue\n</code></pre> Source code in <code>src/talvez/predicates.py</code> <pre><code>def not_undefined(a: Any) -&gt; bool:\n    \"\"\"\n    Composite predicate: value is neither None, NaN, nor infinite.\n\n    This is a convenience aggregator combining:\n      - not_null\n      - not_nan\n      - not_infinite\n\n    Parameters\n    ----------\n    a : Any\n        Value to test.\n\n    Returns\n    -------\n    bool\n        True only if all component predicates pass.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; not_undefined(None)\n    False\n    &gt;&gt;&gt; not_undefined(float(\"nan\"))\n    False\n    &gt;&gt;&gt; not_undefined(float(\"inf\"))\n    False\n    &gt;&gt;&gt; not_undefined(0)\n    True\n    ```\n    \"\"\"\n    return all([\n        not_null(a),\n        not_nan(a),\n        not_infinite(a),\n    ])\n</code></pre>"},{"location":"reference/#talvez.predicates.not_empty--parameters","title":"Parameters","text":"<p>a : Any     Value or container to check.</p>"},{"location":"reference/#talvez.predicates.not_empty--returns","title":"Returns","text":"<p>bool     False only when a length can be determined AND that length is 0.</p>"},{"location":"reference/#talvez.predicates.not_empty--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; not_empty([])\nFalse\n&gt;&gt;&gt; not_empty([1])\nTrue\n&gt;&gt;&gt; not_empty(\"\")\nFalse\n&gt;&gt;&gt; not_empty(\"hi\")\nTrue\n&gt;&gt;&gt; class NoLen: pass\n&gt;&gt;&gt; not_empty(NoLen())\nTrue  # no length concept -&gt; considered not empty\n</code></pre>"},{"location":"reference/#talvez.predicates.not_empty--notes","title":"Notes","text":"<p>Choosing to treat objects without a length as \"not empty\" avoids false negatives on scalar values; adjust if your domain requires stricter checks.</p> Source code in <code>src/talvez/predicates.py</code> <pre><code>def not_empty(a: Any) -&gt; bool:\n    \"\"\"\n    Return True if the object has a length &gt; 0, or if it has no length concept.\n\n    Semantics:\n      - If the object implements __len__, returns len(a) &gt; 0.\n      - If it does not (AttributeError / TypeError), treats it as \"not empty\"\n        and returns True (optimistic / permissive behavior).\n\n    Parameters\n    ----------\n    a : Any\n        Value or container to check.\n\n    Returns\n    -------\n    bool\n        False only when a length can be determined AND that length is 0.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; not_empty([])\n    False\n    &gt;&gt;&gt; not_empty([1])\n    True\n    &gt;&gt;&gt; not_empty(\"\")\n    False\n    &gt;&gt;&gt; not_empty(\"hi\")\n    True\n    &gt;&gt;&gt; class NoLen: pass\n    &gt;&gt;&gt; not_empty(NoLen())\n    True  # no length concept -&gt; considered not empty\n    ```\n\n    Notes\n    -----\n    Choosing to treat objects without a length as \"not empty\" avoids false\n    negatives on scalar values; adjust if your domain requires stricter checks.\n    \"\"\"\n    try:\n        return len(a) &gt; 0  # type: ignore[arg-type]\n    except Exception:\n        return True\n</code></pre>"},{"location":"reference/#logical-combinators","title":"Logical combinators","text":"<p>Logical AND combinator for predicates.</p> <p>Returns a new predicate that evaluates each provided predicate in order. Short-circuits and returns False on the first predicate that does NOT strictly return the boolean True (identity check). Any truthy non-True value (e.g. 1) is considered a failure, enforcing discipline in predicate implementations.</p> <p>Logical OR combinator for predicates.</p> <p>Returns a predicate that evaluates each provided predicate in order and short-circuits on the first that returns the literal True. Exceptions inside individual predicates are swallowed (treated as a non-match) to keep the OR robust.</p> <p>Tip</p> <p>These are strict: each predicate must return the literal <code>True</code> to be considered a pass. Any other truthy value will fail the conjunction (<code>and_</code>) or be ignored in the disjunction (<code>or_</code>).</p>"},{"location":"reference/#talvez.predicates.and_--parameters","title":"Parameters","text":"<p>*preds : Predicate     Predicates of signature (Any) -&gt; bool.</p>"},{"location":"reference/#talvez.predicates.and_--returns","title":"Returns","text":"<p>Predicate     Composite predicate representing logical conjunction.</p>"},{"location":"reference/#talvez.predicates.and_--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; p = and_(not_null, not_nan, not_infinite)\n&gt;&gt;&gt; p(10)\nTrue\n&gt;&gt;&gt; p(float(\"nan\"))\nFalse\n&gt;&gt;&gt; p(None)\nFalse\n</code></pre>"},{"location":"reference/#talvez.predicates.and_--edge-cases","title":"Edge Cases","text":"<ul> <li>No predicates: returns a predicate that always returns True.</li> </ul> Source code in <code>src/talvez/predicates.py</code> <pre><code>def and_(*preds: Predicate) -&gt; Predicate:\n    \"\"\"\n    Logical AND combinator for predicates.\n\n    Returns a new predicate that evaluates each provided predicate in order.\n    Short-circuits and returns False on the first predicate that does NOT\n    strictly return the boolean True (identity check). Any truthy non-True\n    value (e.g. 1) is considered a failure, enforcing discipline in predicate\n    implementations.\n\n    Parameters\n    ----------\n    *preds : Predicate\n        Predicates of signature (Any) -&gt; bool.\n\n    Returns\n    -------\n    Predicate\n        Composite predicate representing logical conjunction.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; p = and_(not_null, not_nan, not_infinite)\n    &gt;&gt;&gt; p(10)\n    True\n    &gt;&gt;&gt; p(float(\"nan\"))\n    False\n    &gt;&gt;&gt; p(None)\n    False\n    ```\n\n    Edge Cases\n    ----------\n    - No predicates: returns a predicate that always returns True.\n    \"\"\"\n    if not preds:\n        return lambda a: True\n\n    def _combined(a: Any) -&gt; bool:\n        for p in preds:\n            if not_true(p(a)):\n                return False\n        return True\n    return _combined\n</code></pre>"},{"location":"reference/#talvez.predicates.or_--parameters","title":"Parameters","text":"<p>*preds : Predicate     Predicates of signature (Any) -&gt; bool.</p>"},{"location":"reference/#talvez.predicates.or_--returns","title":"Returns","text":"<p>Predicate     Composite predicate representing logical disjunction.</p>"},{"location":"reference/#talvez.predicates.or_--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; p = or_(not_null, not_empty)\n&gt;&gt;&gt; p(None)\nFalse        # both fail\n&gt;&gt;&gt; p(\"\")\nFalse        # not_null OK but empty string -&gt; not_empty False\n&gt;&gt;&gt; p(\"x\")\nTrue\n&gt;&gt;&gt; p([])    # not_null True but empty -&gt; not_empty False -&gt; overall False\nFalse\n</code></pre>"},{"location":"reference/#talvez.predicates.or_--edge-cases","title":"Edge Cases","text":"<ul> <li>No predicates: returns a predicate that always returns False.</li> <li>Non-boolean truthy values returned by individual predicates are ignored   unless they are exactly True, encouraging explicit boolean returns.</li> </ul> Source code in <code>src/talvez/predicates.py</code> <pre><code>def or_(*preds: Predicate) -&gt; Predicate:\n    \"\"\"\n    Logical OR combinator for predicates.\n\n    Returns a predicate that evaluates each provided predicate in order and\n    short-circuits on the first that returns the literal True. Exceptions inside\n    individual predicates are swallowed (treated as a non-match) to keep the OR\n    robust.\n\n    Parameters\n    ----------\n    *preds : Predicate\n        Predicates of signature (Any) -&gt; bool.\n\n    Returns\n    -------\n    Predicate\n        Composite predicate representing logical disjunction.\n\n    Examples\n    --------\n    ```pycon\n    &gt;&gt;&gt; p = or_(not_null, not_empty)\n    &gt;&gt;&gt; p(None)\n    False        # both fail\n    &gt;&gt;&gt; p(\"\")\n    False        # not_null OK but empty string -&gt; not_empty False\n    &gt;&gt;&gt; p(\"x\")\n    True\n    &gt;&gt;&gt; p([])    # not_null True but empty -&gt; not_empty False -&gt; overall False\n    False\n    ```\n\n    Edge Cases\n    ----------\n    - No predicates: returns a predicate that always returns False.\n    - Non-boolean truthy values returned by individual predicates are ignored\n      unless they are exactly True, encouraging explicit boolean returns.\n    \"\"\"\n    if not preds:\n        return lambda a: False\n\n    def _combined(a: Any) -&gt; bool:\n        for p in preds:\n            try:\n                if p(a) is True:\n                    return True\n            except Exception:\n                continue\n        return False\n    return _combined\n</code></pre>"},{"location":"reference/#common-usage-patterns","title":"Common usage patterns","text":"<pre><code>from talvez import maybe, just, nothing, chain, compose_maybe, not_null, and_\n\n@maybe(ensure=lambda x: x &gt; 0)\ndef positive_delta(x: int) -&gt; int:\n    return x - 1\n\npipeline = compose_maybe(\n    lambda x: just(x * 2),\n    lambda y: positive_delta(y)  # returns Maybe[int]\n)\n\nresult = pipeline(just(10))      # Just(19)\nfailed = pipeline(just(0))       # Nothing\n</code></pre>"},{"location":"reference/#error-warning-handling","title":"Error &amp; warning handling","text":"<ul> <li> <p><code>maybe(..., allow_warning=False)</code> turns any emitted warning into failure.</p> </li> <li> <p><code>perhaps(..., allow_warning=True)</code> will ignore warnings and still return the   raw value.</p> </li> </ul>"},{"location":"reference/#interoperability","title":"Interoperability","text":"Purpose Helper Convert Optional[T] to Maybe[T] <code>from_optional</code> Convert Maybe[T] to Optional[T] <code>maybe_val.to_optional()</code> Batch short-circuit across many Maybes <code>sequence(iter_of_maybes)</code>"},{"location":"tutorial/","title":"Tutorial","text":"<p>A comprehensive guide to using the <code>talvez</code> library for safe, composable handling of optional values and fallible computations in Python.</p>"},{"location":"tutorial/#1-introduction","title":"1. Introduction","text":"<p><code>talvez</code> provides small functional primitives centered around a <code>Maybe</code> type, inspired by Haskell, other functional programming ecosystems, and the R <code>{maybe}</code> package. It includes decorators to safely wrap existing functions and compose computations that might fail.</p> <p>The core problem <code>talvez</code> addresses is the inconsistent and often implicit handling of failures in Python. Functions can fail by raising exceptions, returning <code>None</code>, or returning special values like <code>-1</code> or <code>False</code>. This forces developers to write defensive code with scattered <code>try/except</code> blocks and <code>if value is not None:</code> checks, making the main logic harder to follow.</p> <p>Core goals:</p> <ul> <li>Eliminate scattered <code>try/except</code> blocks: By wrapping fallible     operations, <code>talvez</code> contains failures within a predictable structure,     allowing you to handle them explicitly when you choose.</li> <li>Make failure explicit: Instead of relying on exceptions or ambiguous     <code>None</code> returns, failure is represented by a single, explicit type:     <code>Nothing</code>. This makes your function signatures more honest about what they     can return.</li> <li>Provide ergonomic wrappers (<code>@maybe</code>, <code>@perhaps</code>): These decorators     allow you to easily retrofit existing code to use this safer pattern without     major refactoring.</li> <li>Offer simple combinators for building pipelines: Easily chain together     multiple fallible operations in a readable, robust way.</li> </ul>"},{"location":"tutorial/#2-installation","title":"2. Installation","text":"<p>Just use whatever package manager is the current popular one.</p>"},{"location":"tutorial/#3-the-maybe-type","title":"3. The Maybe Type","text":"<p>The <code>Maybe</code> type is the heart of the library. It's a generic container that represents a value that may or may not be present. A <code>Maybe</code> is one of two things:</p> <ol> <li><code>Just(value)</code>: A container holding a successful result.</li> <li><code>Nothing</code>: An empty container representing any kind of failure (an exception     occurred, a validation check failed, etc.).</li> </ol> <p>This explicitness is its power. A function that returns <code>Maybe[int]</code> tells you it will either give you an <code>int</code> (wrapped in <code>Just</code>) or it will give you <code>Nothing</code>.</p> <pre><code>from talvez import just, nothing, Maybe\n\n# Create a Maybe holding a value\nx = just(42)\nprint(x)  # Output: Just(42)\n\n# Create a Maybe representing failure\ny = nothing()\nprint(y)  # Output: Nothing\n\n# You can check the state of a Maybe\nassert x.is_just is True\nassert x.is_nothing is False\nassert y.is_nothing is True\n</code></pre>"},{"location":"tutorial/#key-methods","title":"Key Methods","text":"<p>A <code>Maybe</code>'s value is wrapped and cannot be accessed directly. You interact with it through safe methods.</p> <ul> <li> <p><code>fmap(fn)</code>: (Functor map) If the <code>Maybe</code> is a <code>Just</code>, it applies a regular     Python function to the inner value and wraps the result in a new <code>Just</code>.     If it's <code>Nothing</code>, it does nothing and returns <code>Nothing</code>.</p> <p><code>python just(10).fmap(lambda v: v + 5)          # Returns Just(15) nothing().fmap(lambda v: v + 5)         # Returns Nothing just(\"hello\").fmap(str.upper)           # Returns Just('HELLO')</code></p> </li> <li> <p><code>bind(fn)</code>: (Monadic bind) This is for chaining functions that already     return a <code>Maybe</code>. If the <code>Maybe</code> is a <code>Just</code>, <code>bind</code> applies the function     to the inner value. If it's <code>Nothing</code>, it returns <code>Nothing</code>. This is the     primary tool for building pipelines.</p> <p>```python</p> </li> <li> <p><code>get_or(default)</code>: Extracts the value from a <code>Just</code> or returns the <code>default</code>     value if it's <code>Nothing</code>. This is how you exit the <code>Maybe</code> world.</p> <p><code>python just(100).get_or(0)    # Returns 100 nothing().get_or(0)    # Returns 0</code></p> </li> <li> <p><code>to_optional()</code>: Converts the <code>Maybe</code> to a standard Python <code>Optional</code>,     returning the raw value or <code>None</code>.</p> <p><code>python just(\"value\").to_optional() # Returns \"value\" nothing().to_optional()     # Returns None</code></p> </li> </ul>"},{"location":"tutorial/#a-function-that-can-fail-and-returns-a-maybe","title":"A function that can fail and returns a Maybe","text":"<p>def safe_inverse(n: float) -&gt; Maybe[float]:     return just(1/n) if n != 0 else nothing()</p> <p>just(4).bind(safe_inverse)    # Returns Just(0.25) just(0).bind(safe_inverse)    # Returns Nothing nothing().bind(safe_inverse)  # Returns Nothing ```</p>"},{"location":"tutorial/#31-creating-maybes-from-optionals","title":"3.1. Creating Maybes From Optionals","text":"<p>The <code>from_optional</code> helper function provides a clean way to convert standard Python <code>None</code>-based logic into the <code>Maybe</code> type.</p> <pre><code>from talvez import from_optional\n\n# A function that might return None\ndef find_user(user_id: int) -&gt; str | None:\n    if user_id == 1:\n        return \"Alice\"\n    return None\n\nmaybe_user = from_optional(find_user(1))  # Just('Alice')\nmaybe_nobody = from_optional(find_user(2)) # Nothing\n</code></pre>"},{"location":"tutorial/#32-sequencing-a-collection-of-maybes","title":"3.2. Sequencing a Collection of Maybes","text":"<p>The <code>sequence</code> function is used to convert an iterator of <code>Maybe</code>s into a single <code>Maybe</code> of a list. It short-circuits, meaning if any element in the collection is <code>Nothing</code>, the entire result is <code>Nothing</code>. This is useful for validating multiple inputs at once.</p> <pre><code>from talvez import sequence, just, nothing\n\n# All succeed\nmaybes1 = iter([just(1), just(2), just(3)])\nresult1 = sequence(maybes1)\nassert result1.get_or([]) == [1, 2, 3]\n\n# One fails\nmaybes2 = iter([just(1), nothing(), just(3)])\nresult2 = sequence(maybes2)\nassert result2.is_nothing is True\n</code></pre>"},{"location":"tutorial/#4-wrapping-existing-functions-with-decorators","title":"4. Wrapping Existing Functions With Decorators","text":"<p>Decorators are the most ergonomic way to integrate <code>talvez</code> into an existing codebase. They automatically wrap a function's execution, handling exceptions and validation for you.</p>"},{"location":"tutorial/#41-maybe","title":"4.1. @maybe","text":"<p><code>@maybe</code> converts a function that could raise an exception or return an invalid result into one that safely returns a <code>Maybe</code>.</p> <p>Behavior:</p> <ul> <li>Catches any exception: If the wrapped function raises any <code>Exception</code>,     <code>@maybe</code> catches it and returns <code>Nothing</code>.</li> <li>Enforces a predicate (<code>ensure</code>): You can provide a function to the     <code>ensure</code> argument. After the original function executes successfully, its     result is passed to the <code>ensure</code> function. If it doesn't return <code>True</code>, the     result is discarded and <code>Nothing</code> is returned.</li> <li>Handles warnings: By default, warnings are ignored. If you set     <code>allow_warning=False</code>, any warning emitted during the function's execution     will be treated as a failure, causing it to return <code>Nothing</code>.</li> </ul> <p>Basic Example (Exception Handling):</p> <pre><code>from talvez import maybe\n\n@maybe()\ndef parse_int(x: str) -&gt; int:\n    return int(x)\n\n# Before: parse_int(\"xyz\") would raise a ValueError.\n# After: It safely returns Nothing.\nassert parse_int(\"10\").get_or(0) == 10\nassert parse_int(\"xyz\").is_nothing is True\n</code></pre> <p>With a Predicate:</p> <p>The <code>ensure</code> predicate validates the successful return value.</p> <pre><code># We want a function that only returns positive numbers\n@maybe(ensure=lambda v: v &gt; 0)\ndef parse_positive_int(x: str) -&gt; int:\n    return int(x)\n\nassert parse_positive_int(\"123\").get_or(None) == 123\nassert parse_positive_int(\"-5\").is_nothing    # ensure failed\nassert parse_positive_int(\"abc\").is_nothing   # int() raised an exception\n</code></pre> <p>Handling Warnings:</p> <pre><code>import warnings\n\n@maybe(allow_warning=False)\ndef risky_operation():\n    warnings.warn(\"This is a deprecated function\")\n    return 1\n\n# The warning is caught and treated as a failure\nassert risky_operation().is_nothing is True\n\n@maybe(allow_warning=True) # The default behavior\ndef less_risky_operation():\n    warnings.warn(\"This can be ignored\")\n    return 1\n\nassert less_risky_operation().get_or(None) == 1\n</code></pre>"},{"location":"tutorial/#42-perhaps","title":"4.2. @perhaps","text":"<p><code>@perhaps(default=...)</code> is a convenient alternative to <code>@maybe</code>. It behaves identically in terms of catching exceptions and validating results, but instead of returning a <code>Maybe</code> wrapper, it returns the raw value on success and a specified <code>default</code> value on any failure.</p> <p>Use <code>@perhaps</code> when you want to immediately fall back to a default value rather than carrying the <code>Maybe</code> context forward.</p> <pre><code>from talvez import perhaps\n\n@perhaps(default=0.0)\ndef safe_div(a, b):\n    return a / b\n\nresult1 = safe_div(10, 2)  # 5.0\nresult2 = safe_div(10, 0)  # 0.0 (fallback on ZeroDivisionError)\n\n# Using @maybe would require an extra step:\n# @maybe()\n# def maybe_div(a,b): return a/b\n# result = maybe_div(10,0).get_or(0.0)\n</code></pre>"},{"location":"tutorial/#5-predicates-and-composition","title":"5. Predicates and Composition","text":"<p>Predicates are simple functions that take a value and return <code>True</code> or <code>False</code>. They are used with the <code>ensure</code> argument in decorators to perform validation. <code>talvez</code> provides several common predicates out of the box.</p> <ul> <li><code>not_null</code>: Checks <code>value is not None</code>.</li> <li><code>not_nan</code>: Checks that a float is not <code>NaN</code>.</li> <li><code>not_infinite</code>: Checks that a number is not <code>inf</code> or <code>-inf</code>.</li> <li><code>not_undefined</code>: A combination of <code>not_null</code>, <code>not_nan</code>, and <code>not_infinite</code>.</li> <li><code>not_empty</code>: For sized objects (like strings, lists), checks <code>len(value) &gt; 0</code>. For non-sized objects, it passes.</li> </ul> <p>You can combine these predicates using <code>and_</code> and <code>or_</code> to build more complex validation logic.</p> <ul> <li><code>and_(*preds)</code>: Creates a new predicate that succeeds only if all child predicates return <code>True</code>.</li> <li><code>or_(*preds)</code>: Creates a new predicate that succeeds if at least one child predicate returns <code>True</code>.</li> </ul> <p>Example:</p> <p>Let's create a validator for a user profile name, which must exist and not be empty whitespace.</p> <pre><code>from talvez import maybe, not_null, not_empty, and_\n\n# This predicate ensures the name is not None and not an empty string.\nis_valid_name = and_(not_null, not_empty)\n\n@maybe(ensure=is_valid_name)\ndef build_name(first: str, last: str) -&gt; str:\n    # We strip whitespace before validation, but if the string is empty\n    # after stripping, not_empty will catch it.\n    full_name = f\"{first.strip()} {last.strip()}\"\n    return full_name if full_name.strip() else \"\"\n\nassert build_name(\"Ada\", \"Lovelace\").get_or(None) == \"Ada Lovelace\"\nassert build_name(\"  \", \"Lovelace\").is_nothing # Fails not_empty after strip\nassert build_name(\"Grace\", \"\").is_nothing     # Fails not_empty after strip\n</code></pre>"},{"location":"tutorial/#6-chaining-and-pipelines","title":"6. Chaining and Pipelines","text":"<p>The true power of <code>Maybe</code> emerges when you compose multiple fallible operations. If any step in the chain fails, the entire subsequent chain is skipped, and <code>Nothing</code> is propagated to the end.</p>"},{"location":"tutorial/#61-manual-chaining-with-bind","title":"6.1. Manual Chaining With <code>bind</code>","text":"<p>You can manually chain operations using the <code>bind</code> method. This is explicit and very readable for simple pipelines.</p> <pre><code>from talvez import just, maybe\n\n@maybe()\ndef parse(s: str) -&gt; int:\n    return int(s.strip())\n\n@maybe(ensure=lambda i: i &gt; 0)\ndef ensure_positive(i: int) -&gt; int:\n    return i\n\nresult = (just(\"  42  \")\n          .bind(parse)                 # Becomes Just(42)\n          .bind(ensure_positive)       # Still Just(42)\n          .fmap(lambda i: i * 2))      # Becomes Just(84)\n\nassert result.get_or(None) == 84\n\n# A failing example\nfailing_result = (just(\" -10 \")\n                  .bind(parse)             # Becomes Just(-10)\n                  .bind(ensure_positive)   # Becomes Nothing here\n                  .fmap(lambda i: i * 2))  # This step is skipped\n\nassert failing_result.is_nothing is True\n</code></pre>"},{"location":"tutorial/#62-chain-utility","title":"6.2. <code>chain</code> Utility","text":"<p>The <code>chain</code> utility simplifies the process of applying a sequence of functions that each return a <code>Maybe</code>. It is syntactic sugar for a series of <code>bind</code> calls.</p> <pre><code>from talvez import maybe, just, chain\n\n@maybe()\ndef step1(x: int): return x + 10\n\n@maybe()\ndef step2(x: int): return x * 3\n\n@maybe(ensure=lambda v: v &lt; 50)\ndef step3_with_validation(x: int): return x + 5\n\n# Success case\nres_ok = chain(just(5), step1, step2, step3_with_validation) # ((5+10)*3)+5 = 50. Fails validation.\n# Let's adjust step3 to succeed\n@maybe(ensure=lambda v: v &lt;= 50)\ndef step3_fixed(x: int): return x + 5\nres_ok_fixed = chain(just(5), step1, step2, step3_fixed) # ((5+10)*3)+5 = 50. Passes validation.\nassert res_ok.is_nothing is True\nassert res_ok_fixed.get_or(None) == 50\n\n# Failure case\nres_fail = chain(just(10), step1, step2, step3_with_validation) # ((10+10)*3)+5 = 65. Fails validation at step3.\nassert res_fail.is_nothing is True\n</code></pre>"},{"location":"tutorial/#63-compose_maybe-for-reusable-pipelines","title":"6.3. <code>compose_maybe</code> for Reusable Pipelines","text":"<p>If you have a pipeline that you need to reuse, <code>compose_maybe</code> lets you define it once as a single function.</p> <pre><code>from talvez import compose_maybe\n\n# Using the same step functions from the previous example\npipeline = compose_maybe(step1, step2, step3_fixed)\n\n# Now 'pipeline' is a function that takes a Maybe and runs it through the steps.\nassert pipeline(just(5)).get_or(None) == 50\nassert pipeline(just(10)).is_nothing is True # Fails at step3\nassert pipeline(nothing()).is_nothing is True # Starts with Nothing, remains Nothing\n</code></pre>"},{"location":"tutorial/#7-error-vs-failure-semantics","title":"7. Error vs. Failure Semantics","text":"<p><code>talvez</code> standardizes how failures are handled, making your code's behavior predictable.</p> Scenario <code>@maybe</code> outcome <code>@perhaps(default=D)</code> outcome Function executes successfully <code>Just(value)</code> <code>value</code> Function raises an exception <code>Nothing</code> <code>D</code> (default value) <code>ensure</code> predicate returns <code>False</code> <code>Nothing</code> <code>D</code> (default value) Warning emitted &amp; <code>allow_warning=False</code> <code>Nothing</code> <code>D</code> (default value) <p>This uniform table simplifies reasoning about the reliability and output of any function decorated with <code>talvez</code>.</p>"},{"location":"tutorial/#8-interoperability-migration","title":"8. Interoperability &amp; Migration","text":""},{"location":"tutorial/#81-gradual-adoption","title":"8.1. Gradual Adoption","text":"<p>You don't need to rewrite your entire application to use <code>talvez</code>. The best approach is to start at the \"edges\" of your system\u2014places where your code interacts with the messy outside world.</p> <ul> <li>Parsing / Validation: Wrap functions that parse user input, config     files, or API responses.</li> <li>External I/O: Wrap functions that read files, make network requests, or     query a database. These can all fail for reasons beyond your control.</li> <li>Optional Configuration: Instead of <code>config.get('key')</code> which returns     <code>None</code>, wrap it to return a <code>Maybe</code>.</li> </ul> <p>Once the inputs to a system are safely wrapped in <code>Maybe</code>, you can propagate that safety inward as needed.</p>"},{"location":"tutorial/#82-converting-back-to-exceptions-if-needed","title":"8.2. Converting Back to Exceptions (If Needed)","text":"<p>Sometimes you need to interact with a library or framework that expects exceptions. It's easy to exit the \"Maybe world\" and raise an exception.</p> <pre><code>@maybe()\ndef parse_int(x: str) -&gt; int:\n    return int(x)\n\nraw_input = \"x\"\nparsed_value = parse_int(raw_input)\n\nif parsed_value.is_nothing:\n    raise ValueError(f\"Invalid integer provided: {raw_input}\")\n\n# Now you can safely use the value\nuse_value(parsed_value.get_or(0)) # Or just parsed_value.value\n</code></pre>"},{"location":"tutorial/#83-using-with-type-checkers","title":"8.3. Using With Type Checkers","text":"<p>Type checkers like Mypy understand <code>Maybe</code> because it's defined as a <code>Union</code>. This allows you to get static analysis benefits. After you check <code>is_just</code>, the type checker knows the value is present.</p> <pre><code>m = parse_int(\"12\")  # Type of m is Maybe[int]\n\nif m.is_just:\n    # Inside this block, the type checker knows `m` is Just[int]\n    # and that `m.value` exists and is an `int`.\n    print(m.value + 10) # No type error\n</code></pre>"},{"location":"tutorial/#9-advanced-patterns","title":"9. Advanced Patterns","text":""},{"location":"tutorial/#91-lifting-multi-arg-functions","title":"9.1. Lifting Multi-Arg Functions","text":"<p>Decorators work best on functions that will be the start of a <code>chain</code>. If you have a multi-argument function you want to use mid-pipeline, wrap it first and then use <code>functools.partial</code> or a <code>lambda</code> to supply the other arguments.</p> <pre><code>from functools import partial\nfrom talvez import maybe, just, chain\n\n@maybe()\ndef div(a: int, b: int) -&gt; float:\n    return a / b\n\n# We want a pipeline that takes a number and divides it by 2.\n# We can't pass `div` directly to `chain` because it needs two arguments.\n\n# Option 1: Lambda\npipeline1 = chain(just(20), lambda x: div(x, 2))\nassert pipeline1.get_or(None) == 10.0\n\n# Option 2: functools.partial\nsafe_div_by_2 = partial(div, b=2)\n# Whoops, partial doesn't work that way. We need to flip the arguments.\nsafe_div_by = lambda numerator, denominator: div(numerator, denominator)\npipeline2 = chain(just(20), lambda x: safe_div_by(x, 2))\nassert pipeline2.get_or(None) == 10.0\n</code></pre>"},{"location":"tutorial/#92-conditional-branching","title":"9.2. Conditional Branching","text":"<p>You can use <code>bind</code> with a <code>lambda</code> to introduce conditional logic into a pipeline. If a condition isn't met, you can switch the pipeline to the <code>Nothing</code> track.</p> <pre><code># A pipeline to process even numbers under 20\nresult = (just(18)\n          .fmap(lambda v: v - 4)  # Becomes Just(14)\n          .bind(lambda v: just(v) if v % 2 == 0 else nothing()) # Condition passes\n          .fmap(lambda v: v * 10)) # Becomes Just(140)\n\nassert result.get_or(None) == 140\n\n# A failing case\nresult_fail = (just(17)\n              .fmap(lambda v: v - 4) # Becomes Just(13)\n              .bind(lambda v: just(v) if v % 2 == 0 else nothing()) # Condition fails, becomes Nothing\n              .fmap(lambda v: v * 10)) # Skipped\n\nassert result_fail.is_nothing is True\n</code></pre>"},{"location":"tutorial/#93-aggregating-independent-maybes","title":"9.3. Aggregating Independent Maybes","text":"<p>The <code>sequence</code> function is the canonical way to handle this. If you have multiple independent <code>Maybe</code> values and you need them all to be <code>Just</code> to proceed, <code>sequence</code> is the tool.</p> <pre><code>from talvez import sequence\n\n@maybe()\ndef get_user_id(username: str) -&gt; int:\n    return {\"alice\": 1, \"bob\": 2}.get(username)\n\n# Get multiple inputs\nuser_ids = [get_user_id(\"alice\"), get_user_id(\"bob\")] # [Just(1), Just(2)]\nall_good = sequence(iter(user_ids))\nassert all_good.get_or(None) == [1, 2]\n\n# One input fails\nbad_user_ids = [get_user_id(\"alice\"), get_user_id(\"charlie\")] # [Just(1), Nothing]\none_failed = sequence(iter(bad_user_ids))\nassert one_failed.is_nothing is True\n</code></pre>"},{"location":"tutorial/#94-decorating-methods","title":"9.4. Decorating Methods","text":"<p>The decorators work on instance methods and class methods just as they do on regular functions. The <code>self</code> or <code>cls</code> argument is handled correctly.</p> <pre><code>class Calculator:\n    def __init__(self, allow_zero=False):\n        self.allow_zero = allow_zero\n\n    @maybe()\n    def inverse(self, x: float) -&gt; float:\n        if x == 0 and not self.allow_zero:\n            raise ValueError(\"Zero is not allowed\")\n        return 1 / x\n\ncalc = Calculator()\nassert calc.inverse(4).get_or(None) == 0.25\nassert calc.inverse(0).is_nothing is True\n</code></pre>"},{"location":"tutorial/#10-testing-strategies","title":"10. Testing Strategies","text":"<p>When testing functions that return <code>Maybe</code>, you should test both the success and failure paths explicitly.</p> <ul> <li>Assert the structure: For a successful input, assert the result     <code>is_just</code>. For a failing input, assert it <code>is_nothing</code>. This is more robust     than only checking the unwrapped value.</li> <li>Assert the value: For a <code>Just</code> result, you can then check its contents     using <code>get_or</code> or by accessing <code>.value</code> after an <code>is_just</code> check.</li> <li>Use property tests: For functional types like <code>Maybe</code>, property-based     testing is very effective. For example, for any value <code>x</code>,     <code>just(x).fmap(lambda y: y)</code> should always equal <code>just(x)</code>.</li> </ul> <p>Example Test Case:</p> <pre><code>from talvez import just\n\n# Assuming parse_positive_int from a previous example\ndef test_parse_positive_int_success():\n    result = parse_positive_int(\"100\")\n    assert result.is_just\n    assert result.get_or(0) == 100\n\ndef test_parse_positive_int_failure_on_negative():\n    result = parse_positive_int(\"-5\")\n    assert result.is_nothing\n\ndef test_parse_positive_int_failure_on_invalid_string():\n    result = parse_positive_int(\"not a number\")\n    assert result.is_nothing\n\ndef test_fmap_identity_law():\n    # Property: mapping the identity function over a Just should not change it.\n    j = just(5)\n    assert j.fmap(lambda x: x) == j\n</code></pre>"},{"location":"tutorial/#11-performance-notes","title":"11. Performance Notes","text":"<ul> <li>Minimal Overhead: The overhead of wrapping a value in a <code>Just</code> dataclass     or creating a <code>Nothing</code> singleton is very small. The logic inside the     decorators is also lightweight.</li> <li>Best Use Cases: The library is ideal for I/O-bound operations, data     processing pipelines, and request-level logic where the clarity and safety     gains far outweigh the minuscule performance cost.</li> <li>Hot Loops: Avoid using <code>Maybe</code> wrappers inside tight,     performance-critical loops where millions of operations are performed per     second. In those scenarios, traditional error handling or raw primitives     might be faster.</li> </ul> <p>If profiling ever indicates a bottleneck, you can make targeted optimizations: *   Inline simple predicate checks instead of using the <code>ensure</code> argument. *   Use <code>sequence</code> to validate a list of items in one go rather than in a Python loop.</p>"},{"location":"tutorial/#12-comparison-with-alternatives","title":"12. Comparison With Alternatives","text":"Approach Pros Cons Exceptions Native to Python, provides a full stack trace. Can be verbose (<code>try/except</code>), encourages non-local control flow, makes function signatures lie. Returning <code>None</code> Simple and common in Python. Ambiguous: Does <code>None</code> mean failure or a valid result? Requires constant <code>if x is not None</code> checks. Sentinel Objects Explicit about failure. Requires defining custom sentinel objects, adds boilerplate, not easily composable. <code>talvez</code> <code>Maybe</code> Explicit, composable, clean pipelines, safe. Introduces a new (but simple) concept, requires a small library dependency."},{"location":"tutorial/#13-common-pitfalls","title":"13. Common Pitfalls","text":"Pitfall Explanation Fix Forgetting <code>ensure</code> predicate semantics The <code>ensure</code> function must return <code>True</code> for the pipeline to continue. Returning <code>None</code> or <code>False</code> will be treated as a failure. Ensure your predicate function always returns an explicit boolean: <code>return value &gt; 0</code> not just <code>value &gt; 0</code>. Nesting Maybes by mistake Using <code>.fmap()</code> with a function that already returns a <code>Maybe</code> will result in a nested <code>Maybe</code>, like <code>Just(Just(5))</code>. Use <code>.bind()</code> when your function returns a <code>Maybe</code>. <code>bind</code> automatically flattens the result. Using <code>.value</code> without checking Accessing the <code>.value</code> property on a <code>Nothing</code> instance will raise an <code>AttributeError</code>. The property only exists on <code>Just</code>. Always use <code>.get_or(default)</code> or guard the access with an <code>if m.is_just:</code> check. Applying <code>chain</code> to a raw value The <code>chain</code> function expects its first argument to be a <code>Maybe</code>. Passing a raw value like <code>chain(5, ...)</code> will fail. Always start your chain with a <code>Maybe</code>, e.g., <code>chain(just(5), ...)</code>."},{"location":"tutorial/#14-roadmap-ideas","title":"14. Roadmap Ideas","text":"<ul> <li>Async-aware decorators: Create <code>@maybe_async</code> that can wrap and await     coroutine functions.</li> <li>Mypy Plugin: A plugin could potentially improve type narrowing and     inference for more complex pipeline scenarios.</li> <li>Additional Helpers: Add more functional combinators like <code>lift</code> to adapt     multi-argument functions to work on <code>Maybe</code> types seamlessly.</li> <li>Integration with Validation Libraries: Create adapters for popular     libraries like Pydantic to bridge their validation failures into the <code>Maybe</code>     ecosystem.</li> </ul>"},{"location":"tutorial/#15-quick-reference","title":"15. Quick Reference","text":"<p>Here is a small, complete example showcasing the core features.</p> <pre><code>from talvez import just, maybe, chain\n\n# Step 1: Parse a string, but only if it's a digit.\n@maybe(ensure=str.isdigit)\ndef get_digit_str(s: str) -&gt; str:\n    return s.strip()\n\n# Step 2: Convert to integer.\n@maybe()\ndef to_int(s: str) -&gt; int:\n    return int(s)\n\n# Step 3: Increment the integer, but only if it's positive.\n@maybe(ensure=lambda v: v &gt; 0)\ndef inc_positive(x: int) -&gt; int:\n    return x + 1\n\n# Chain the operations together starting with a raw value\nresult = chain(just(\" 41 \"), get_digit_str, to_int, inc_positive)\n\nassert result.get_or(None) == 42\n\n# A failing example\nfailing_result = chain(just(\" -5 \"), get_digit_str, to_int, inc_positive)\nassert failing_result.is_nothing is True\n</code></pre>"},{"location":"tutorial/#16-closing-thoughts","title":"16. Closing Thoughts","text":"<p><code>talvez</code> offers a pragmatic middle ground between Python's traditional error handling and the all-in approach of purely functional languages. It provides functional-style safety without heavy abstractions or a steep learning curve.</p> <p>The best way to get started is to find a small, risky part of your codebase\u2014like parsing an API response\u2014and wrap it with <code>@maybe</code>. See how it cleans up your logic, and grow the pattern organically from there.</p> <p>Feedback and contributions are welcome.</p>"}]}